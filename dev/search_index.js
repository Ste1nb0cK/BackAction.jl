var documenterSearchIndex = {"docs":
[{"location":"getting_started/#Installation","page":"Getting Started","title":"Installation","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"For the moment the library is not available through Pkg, so you will need to clone the repository ","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"$ git clone https://github.com/Ste1nb0cK/BackAction.jl","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"and build it with ] develop path_to_clonedrepo in the Julia REPL, this automatically adds it to your current project. ","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"import Pkg; Pkg.develop(path=\"./BackAction.jl\")","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"To check the installation do","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Pkg.status","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"and you should see BackAction in the output e.g.","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"  [32f8aca8] BackAction v0.1.0 `..`\n  [e30172f5] Documenter v1.8.0\n  [daee34ce] DocumenterCitations v1.3.5\n  [b964fa9f] LaTeXStrings v1.4.0\n  [91a5bcdd] Plots v1.40.9\n  [10745b16] Statistics v1.10.0\n  [8dfed614] Test\n","category":"page"},{"location":"getting_started/#Example:-Jump-Unraveling-of-a-Driven-Qubit","page":"Getting Started","title":"Example: Jump Unraveling of a Driven Qubit","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"To explain how the library works  we'll consider a driven qubit in a thermal enviroment,  whose density matrix follows the Lindblad equation [1]:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"dotrho=-iHrho+gamma(n+1)mathcalDsigma^-rho+gamma nmathcalDsigma^+rho","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"where sigma^- (sigma^+) is the lowering (raising) atomic operator and","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"H=frac12Deltasigma_z+frac12Omegasigma_x","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"mathcalDsigma^pmrho = sigma^pmrhosigma^mp-frac12sigma^mpsigma^pm rho","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"To it we associate the Stochastic Jump Unraveling:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"drho=-iHrhodt+left(fracsigma^-rhosigma^+mathrmTr(sigma^-rhosigma^+)-rhoright)dN_1\n+ left(fracsigma^+rhosigma^-mathrmTr(sigma^+rhosigma^-)-rhoright)dN_2","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"whose ensemble average returns the Lindblad equation. Our objective, and the main functionality  of the library, is to sample trajectories of this type of equations and obtain from them relevant physical quantities.","category":"page"},{"location":"getting_started/#Basic-Definitions","page":"Getting Started","title":"Basic Definitions","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"The basic way to use the library is to first define the system and  the conditions of the simulation via the structs System and SimulParameters (see System and SimulParameters). ","category":"page"},{"location":"getting_started/#Defining-the-System","page":"Getting Started","title":"Defining the System","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"System is the struct intended to store all the relevant information of the system of interest. ","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"using BackAction\ndelta = 1.43\ngamma = 1.0\nomega = 1.3\nnbar = 0.2\n# Note: the library already has a dedicated variables for the Pauli matrices.\nH = 0.5*delta * BackAction.sigma_z + 0.5*omega*BackAction.sigma_x\n# Define the jump operators\nL1 = sqrt(gamma*(nbar+1))*BackAction.sigma_m\nL2 = sqrt(gamma*(nbar))*BackAction.sigma_p\nsys = System(H, [L1, L2])\nprint(sys)","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"As you can see to create a System type one only needs the hamiltonian and the jump operators, the internal constructor takes care of infering all the derived quantities.","category":"page"},{"location":"getting_started/#Defining-the-Simulation","page":"Getting Started","title":"Defining the Simulation","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"All the information related to the details of generating a sample is organized with the struct SimulParameters. The initial state might be mixed (Matrix) or pure (Vector), the library takes care of handling each case  efficiently.","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":" # As initial condition use a mixture of |+> and |-> states\nplus = 0.5* [[1.0+0im, 1] [1,  1]]\nminus = 0.5* [[1.0+0im, -1] [-1,  1]]\npsi0 = 0.3*plus + 0.7*minus\n\nparams = SimulParameters(psi0,\n    25.0, # Final time\n    1, # seed\n    3, # Number of trajectories\n    25_000, # Number of samples in the finegrid\n    4.0, # Multiplier to use in the fine grid\n    1e-3 # Tolerance for passing Dark state test\n)\nprint(params)","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"For the moment the only available method of solution is the /Quantum Gillipsie Algorithm/ presented in [2]. The multiplier is used to generate the finegrid from which one samples the waiting times. Basically that finegrid is a discretization of (dt, params.multiplier * params.tf) with step size params.dt. A small but important difference with the original implementationis that here in each iteration the normalization of the WTD is checked; in case of undernormalization the current state is declared dark and the sampling stops. Sample quality strongly depends on the size of dt, but in contrast to other methods it's not necessary for it to be effectevely infinitesimal, small enough to resolve the structure of the WTD will suffice.","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"The main bottleneck is in the calculation of the WTD at each jump, this means that the factors that affect the time it takes to sample a single trajectory are mainly the number of samples and total number of jumps that happen in it.","category":"page"},{"location":"getting_started/#ClickDetection-and-Trajectory","page":"Getting Started","title":"ClickDetection and Trajectory","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"The data about a click is modeled by the struct DetectionClick (more info), this in practice works as a glorified tuple. Similarly, the library has an alias for Vector{DetectionClick} called Trajectory. ","category":"page"},{"location":"getting_started/#Sampling-trajectories","page":"Getting Started","title":"Sampling trajectories","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"To obtain a sample of trajectories one uses run_trajectories, this returns a vector of trajectories as the sample :","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"data = run_trajectories(sys, params)\nfor k in 1:3\n    println(data[k])\nend","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"The first element shown of a DetectionClick is the time it took since the last jump to see this click,  and the channel in which it was detected.","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"We can access the clicks in a trajectory doing:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":" traj = data[1] # Trajectory\n click = traj[1] # first click in the trajectory\n print(click.time,\"\\n\") # time we waited to see the jump \n print(click.label, \"\\n\") # Channel in which the jump occured.","category":"page"},{"location":"getting_started/#Obtaining-the-states-and-evaluating-observables","page":"Getting Started","title":"Obtaining the states and evaluating observables","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"To obtain the states of a trajectory at given times the function states_att is used, it evaluates them  from a given initial state and returns an array. Below we use to obtain a sample of the expectation values of the Pauli matrices","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"using LinearAlgebra, Plots, LaTeXStrings\nntimes = 1000 \ntgiven = collect(LinRange(0, params.tf, ntimes));\nstatetrajectory = states_att(tgiven, traj, sys,  params.psi0)\n\n# Obtain sigma_z expectation value over the trajectory\nr_trajectory = zeros(ComplexF64, ntimes, 3)\nfor tn in 1:ntimes\n   r_trajectory[tn, 1] = tr(BackAction.sigma_x*statetrajectory[:,:, tn]) \n   r_trajectory[tn, 2] = tr(BackAction.sigma_y*statetrajectory[:,:, tn]) \n   r_trajectory[tn, 3] = tr(BackAction.sigma_z*statetrajectory[:,:, tn]) \nend \n\nplot(tgiven, real.(r_trajectory[:, 1]), xlabel=L\"t\", ylabel=L\"\\langle\\sigma\\rangle\", color=\"red\", \n    line=:dash, label=L\"\\langle\\sigma_x\\rangle\")\nplot!(tgiven, real.(r_trajectory[:, 2]), color=\"blue\", \n    line=:dash, label=L\"\\langle\\sigma_y\\rangle\")\nplot!(tgiven, real.(r_trajectory[:, 3]), color=\"green\", \n    line=:dash, label=L\"\\langle\\sigma_z\\rangle\")\n","category":"page"},{"location":"getting_started/#Multithreading","page":"Getting Started","title":"Multithreading","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"The library natively supports multithreading, all you need to do is run with the desired number of threads specified in the enviroment variable JULI_NUM_THREADS i.e. do something like export JULIA_NUM_THREADS=4.","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"That would be it!","category":"page"},{"location":"getting_started/#More-Examples","page":"Getting Started","title":"More Examples","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"You can find more elaboted examples in the Jupyter Notebooks available at the repository.","category":"page"},{"location":"system_simulparams/#basic_structs","page":"System and SimulParameters","title":"System and SimulParameters","text":"","category":"section"},{"location":"system_simulparams/","page":"System and SimulParameters","title":"System and SimulParameters","text":"The two basic parts of any workflow are the structs System and SimulParameters.  The former defines the dynamics and the latter the specifics of the simulation e.g. grid precision and number of trajectories.","category":"page"},{"location":"system_simulparams/","page":"System and SimulParameters","title":"System and SimulParameters","text":"System","category":"page"},{"location":"system_simulparams/#BackAction.System","page":"System and SimulParameters","title":"BackAction.System","text":"System(\nNLEVELS::Int64, NCHANNELS::Int64, H::Matrix{ComplexF64}\nLs::Vector{Matrix{ComplexF64}}, J::Matrix{ComplexF64},\nHeff::Matrix{ComplexF64})\n\nA struct that characterizes the dynamics via specification of  the jump and hamiltonian operators.\n\nFields\n\nNLEVELS::Int64: Number of levels of the system\nNCHANNELS::Int64: Number of jump channels\nH::Matrix{ComplexF64}: Hamiltonian\nLs::Vector{Matrix{ComplexF64}}: List of jump operators\nJ::Matrix{ComplexF64}: Sum of all the L_k^*L_k\nHeff::Matrix{ComplexF64}: Effective Hamiltonian\n\nConstructor\n\nTo create an instance it's enough to provide the hamiltonian and the jump operators in a vector. System(H::Matrix{ComplexF64}, Ls::Vector{Matrix{ComplexF64}})\n\n\n\n\n\n","category":"type"},{"location":"system_simulparams/","page":"System and SimulParameters","title":"System and SimulParameters","text":"SimulParameters","category":"page"},{"location":"system_simulparams/#BackAction.SimulParameters","page":"System and SimulParameters","title":"BackAction.SimulParameters","text":"SimulParameters(\n    psi0::Array{ComplexF64}, nsamples::Int64, seed::Int64,\n            ntraj::Int64, multiplier::Float64, tf::Float64,\n            dt::Float64, eps::Float64)\n\nA struct containing all the necessary information for running the the simulation.\n\nFields\n\npsi0::Array{ComplexF64}: Initial state, mixed or pure.\nnsamples::Int64: Number of samples in the finegrid\nseed::Int64: seed\nntraj::Int64: Number of trajectories\nmultiplier::Float64: Multiplier to use in the fine grid\ntf::Float64: Final time\ndt::Float64: time step for the finegrid\neps::Float64: Tolerance for passing WTD normalziation\n\nConstructor\n\nTo create an instance it's enough to provide initial state, final time, seed and number of trajectories. Unless given nsamples, multiplier and eps use default values. SimulParameters(psi0::Vector{ComplexF64}, tf::Float64,         s::Int64, ntraj::Int64, nsamples::Int64=10000, m::Float64=10.0,                              eps::Float64=1e-3)\n\nAbout the multiplier\n\nFor the Gillipsie algorithm to work it's key to have a grid that's capable of resolving the statistical details of the WTD, this grid is taken in the interval (0, tf*multiplier).\n\n\n\n\n\n","category":"type"},{"location":"system_simulparams/#Example","page":"System and SimulParameters","title":"Example","text":"","category":"section"},{"location":"system_simulparams/","page":"System and SimulParameters","title":"System and SimulParameters","text":"Below we give an example using the predefined Pauli matrices available in the package.","category":"page"},{"location":"system_simulparams/","page":"System and SimulParameters","title":"System and SimulParameters","text":"using BackAction\n\n# Define the system\ndeltaomega = 1\ngamma = 1\nH = 0.5*deltaomega * BackAction.sigma_z # 2-level atom hamiltonian\nL = sqrt(gamma) * BackAction.sigma_m # Jump operator for Radiative Damping\nsys = System(H, [L])\n\npsi0 = zeros(ComplexF64, 2)\npsi0[2] = 1 # Initial condition\n\n# Define the parameters\n\nparams = SimulParameters(psi0,\n    3.0, # Final time. Set very long so that all trajectories jump\n    1, # seed\n    1000, # Number of trajectories\n    50_000, # Number of samples in the finegrid\n    10.5, # Multiplier to use in the fine grid\n    1e-3 # Tolerance for passing Dark state test\n)\n\nprint(sys, \"\\n\\n\")\nprint(params, \"\\n\")","category":"page"},{"location":"system_simulparams/#","page":"System and SimulParameters","title":"The DetectionClick Struct","text":"","category":"section"},{"location":"system_simulparams/","page":"System and SimulParameters","title":"System and SimulParameters","text":"To implement the clicks, the struct DetectionClick is used.","category":"page"},{"location":"system_simulparams/","page":"System and SimulParameters","title":"System and SimulParameters","text":"DetectionClick","category":"page"},{"location":"system_simulparams/#BackAction.DetectionClick","page":"System and SimulParameters","title":"BackAction.DetectionClick","text":"DetectionClick(time::Float64, label::Int64)\n\nInmutable struct that represents the clicks by the time waited to see the click and the label of the channel in which it occured.\n\nFields\n\ntime::Float64: Waiting time\nlabel::Int64: Label of the channel of the click\n\n\n\n\n\n\n\n","category":"type"},{"location":"system_simulparams/","page":"System and SimulParameters","title":"System and SimulParameters","text":"Trajectory","category":"page"},{"location":"system_simulparams/#BackAction.Trajectory","page":"System and SimulParameters","title":"BackAction.Trajectory","text":"Alias for Vector{DetectionClick}\n\n\n\n\n\n","category":"type"},{"location":"monitoring_metrology/#Exported-Functions","page":"Monitoring Quantum Metrology","title":"Exported Functions","text":"","category":"section"},{"location":"monitoring_metrology/","page":"Monitoring Quantum Metrology","title":"Monitoring Quantum Metrology","text":"monitoringoperator(t_given::Vector{Float64},\n    sys::System, Heff_par::Function, Ls_par, traj::Trajectory, psi0::Vector{ComplexF64}, theta::Vector{Float64},\n                            dtheta::Vector{Float64})","category":"page"},{"location":"monitoring_metrology/#BackAction.monitoringoperator-Tuple{Vector{Float64}, System, Function, Any, Vector{DetectionClick}, Vector{ComplexF64}, Vector{Float64}, Vector{Float64}}","page":"Monitoring Quantum Metrology","title":"BackAction.monitoringoperator","text":"monitoringoperator(t_given::Vector{Float64},\n    sys::System, Heff_par::Function, Ls_par, traj::Trajectory, psi0::Vector{ComplexF64}, theta::Vector{Float64},\n                            dtheta::Vector{Float64})\n\nTODO: write this documentation\n\n\n\n\n\n","category":"method"},{"location":"monitoring_metrology/","page":"Monitoring Quantum Metrology","title":"Monitoring Quantum Metrology","text":"BackAction.getheff_parametrized(H_par::Function, Ls_par)","category":"page"},{"location":"monitoring_metrology/#BackAction.getheff_parametrized-Tuple{Function, Any}","page":"Monitoring Quantum Metrology","title":"BackAction.getheff_parametrized","text":"getheff_parametrized(H_par::Function, Ls_par)\n\nFrom the function H_par, which is assumed to be the parametrization of the hamiltonian, and an array of functions Ls which are assumed to parametrize the jump operators, return a function that's the  parametrization of the effective Hamiltonian.\n\nnote: About the Arguments\nThe calculation of monitoring operator assumes that the arguments of H_par and the functions in Ls are the same and in the same order.\n\n\n\n\n\n","category":"method"},{"location":"monitoring_metrology/#Internal-Functions","page":"Monitoring Quantum Metrology","title":"Internal Functions","text":"","category":"section"},{"location":"monitoring_metrology/","page":"Monitoring Quantum Metrology","title":"Monitoring Quantum Metrology","text":"\nBackAction.expheff_derivative(Heff_par::Function, tau::Float64, theta::Vector{Float64}, dtheta::Vector{Float64})","category":"page"},{"location":"monitoring_metrology/#BackAction.expheff_derivative-Tuple{Function, Float64, Vector{Float64}, Vector{Float64}}","page":"Monitoring Quantum Metrology","title":"BackAction.expheff_derivative","text":"expheff_derivative(Heff_par::Function, tau::Float64, theta::Vector{Float64}, dtheta::Vector{Float64})\n\nCalculate the derivative  partial_ie^-itau H_e(theta), where i is the i-th component of the vector theta.\n\nArguments\n\nHeff_par::Function: the parametrization of the effective hamiltonian\ntau::Float64: the time in the exponential\ntheta::Vector{Float64}: vector with the values of the parameters at which the derivative is calculated\ndtheta::Vector{Float64}: the displacement vector used to calculate the derivative, if you want the derivative                            respect to the i-th parameter dtheta must have zero entries except for dtheta[i].\n\nnote: Derivative order \nThe derivative is calculate using the five-point stencil rule.\n\ntodo: TODO: add an example\nPreferably one in which  partial_i H_e commutes with H_e, those are easier.\n\n\n\n\n\n","category":"method"},{"location":"monitoring_metrology/","page":"Monitoring Quantum Metrology","title":"Monitoring Quantum Metrology","text":"BackAction.jumpoperators_derivatives(Ls_par, theta::Vector{Float64}, dtheta::Vector{Float64})","category":"page"},{"location":"monitoring_metrology/#BackAction.jumpoperators_derivatives-Tuple{Any, Vector{Float64}, Vector{Float64}}","page":"Monitoring Quantum Metrology","title":"BackAction.jumpoperators_derivatives","text":"jumpoperators_derivatives(Ls_par, theta::Vector{Float64}, dtheta::Vector{Float64})\n\nCalculate the derivatives of the list of jump operators, the logic is the same as for expheff_derivative.\n\n\n\n\n\n","category":"method"},{"location":"monitoring_metrology/","page":"Monitoring Quantum Metrology","title":"Monitoring Quantum Metrology","text":"BackAction.writederivative!(dpsi::SubArray{ComplexF64, 1}, L::Matrix{ComplexF64}, dL::SubArray{ComplexF64, 2}, V::Matrix{ComplexF64}, dV::Matrix{ComplexF64},\npsi0::Vector{ComplexF64})","category":"page"},{"location":"monitoring_metrology/#BackAction.writederivative!-Tuple{SubArray{ComplexF64, 1}, Matrix{ComplexF64}, SubArray{ComplexF64, 2}, Matrix{ComplexF64}, Matrix{ComplexF64}, Vector{ComplexF64}}","page":"Monitoring Quantum Metrology","title":"BackAction.writederivative!","text":"writederivative!(dpsi::SubArray{ComplexF64, 1}, L::Matrix{ComplexF64},\n                          dL::SubArray{ComplexF64, 2},\n                          V::Matrix{ComplexF64}, dV::Matrix{ComplexF64},\n                          psi0::Vector{ComplexF64})\n\nWrites the derivative of psirangle = L(theta)V(theta)psi_0rangle at theta in the subarray dpsi respect to the i-th component of theta, following the same logic as expheff_derivative. The derivatives of V and L at must be provided via dL and dV.\n\nnote: Initial State dependency\nThis is intended to be used when psi_0rangle doesn't have dependeny on theta.\n\n\n\n\n\n","category":"method"},{"location":"monitoring_metrology/","page":"Monitoring Quantum Metrology","title":"Monitoring Quantum Metrology","text":"BackAction.writederivative!(dpsi::SubArray{ComplexF64, 1},L::Matrix{ComplexF64},dL::SubArray{ComplexF64, 2},V::Matrix{ComplexF64}, dV::Matrix{ComplexF64},psi0::SubArray{ComplexF64, 1},dpsi0::SubArray{ComplexF64, 1})","category":"page"},{"location":"monitoring_metrology/#BackAction.writederivative!-Tuple{SubArray{ComplexF64, 1}, Matrix{ComplexF64}, SubArray{ComplexF64, 2}, Matrix{ComplexF64}, Matrix{ComplexF64}, SubArray{ComplexF64, 1}, SubArray{ComplexF64, 1}}","page":"Monitoring Quantum Metrology","title":"BackAction.writederivative!","text":"writederivative!(dpsi::SubArray{ComplexF64, 1},\n                 L::Matrix{ComplexF64},\n                 dL::SubArray{ComplexF64, 2},\n                 V::Matrix{ComplexF64}, dV::Matrix{ComplexF64},\n                 psi0::SubArray{ComplexF64, 1},\n                 dpsi0::SubArray{ComplexF64, 1})\n\nWrites the derivative of psirangle = L(theta)V(theta)psi_0rangle at theta in the subarray dpsi respect to the i-th component of theta, following the same logic as expheff_derivative. The derivatives of V and L at must be provided via dL and dV, and also that of psi0rangle as dpsi0.\n\n\n\n\n\n","category":"method"},{"location":"monitoring_metrology/","page":"Monitoring Quantum Metrology","title":"Monitoring Quantum Metrology","text":"BackAction.derivatives_atjumps(sys::System, Heff_par::Function, Ls_par, traj::Trajectory, psi0::Vector{ComplexF64}, theta::Vector{Float64}, dtheta::Vector{Float64})","category":"page"},{"location":"monitoring_metrology/#BackAction.derivatives_atjumps-Tuple{System, Function, Any, Vector{DetectionClick}, Vector{ComplexF64}, Vector{Float64}, Vector{Float64}}","page":"Monitoring Quantum Metrology","title":"BackAction.derivatives_atjumps","text":"derivatives_atjumps(sys::System, Heff_par::Function, Ls_par, traj::Trajectory, psi0::Vector{ComplexF64}, theta::Vector{Float64},\n                            dtheta::Vector{Float64})\n\n\nTODO: write this documentation\n\n\n\n\n\n","category":"method"},{"location":"monitoring_metrology/","page":"Monitoring Quantum Metrology","title":"Monitoring Quantum Metrology","text":"BackAction.writexi!(xi::SubArray{ComplexF64, 2}, dV::Matrix{ComplexF64},psi::SubArray{ComplexF64, 1}, psi0::Vector{ComplexF64})","category":"page"},{"location":"monitoring_metrology/#BackAction.writexi!-Tuple{SubArray{ComplexF64, 2}, Matrix{ComplexF64}, SubArray{ComplexF64, 1}, Vector{ComplexF64}}","page":"Monitoring Quantum Metrology","title":"BackAction.writexi!","text":"writexi!(xi::SubArray{ComplexF64, 2}, dV::Matrix{ComplexF64},\n         psi::SubArray{ComplexF64, 1}, psi0::Vector{ComplexF64})\n\nTODO: write this documentation\n\n\n\n\n\n","category":"method"},{"location":"monitoring_metrology/","page":"Monitoring Quantum Metrology","title":"Monitoring Quantum Metrology","text":"BackAction.writexi!(xi::SubArray{ComplexF64, 2}, V::Matrix{ComplexF64}, dV::Matrix{ComplexF64}, psijump::SubArray{ComplexF64, 1}, dpsijump::SubArray{ComplexF64, 1},psi::SubArray{ComplexF64, 1})","category":"page"},{"location":"monitoring_metrology/#BackAction.writexi!-Tuple{SubArray{ComplexF64, 2}, Matrix{ComplexF64}, Matrix{ComplexF64}, SubArray{ComplexF64, 1}, SubArray{ComplexF64, 1}, SubArray{ComplexF64, 1}}","page":"Monitoring Quantum Metrology","title":"BackAction.writexi!","text":"writexi!(xi::SubArray{ComplexF64, 2}, V::Matrix{ComplexF64}, dV::Matrix{ComplexF64},           psijump::SubArray{ComplexF64, 1}, dpsijump::SubArray{ComplexF64, 1},          psi::SubArray{ComplexF64, 1}) TODO: write this documentation\n\n\n\n\n\n","category":"method"},{"location":"bibliography/","page":"Bibliography","title":"Bibliography","text":"H. M. Wiseman and G. J. Milburn. Quantum measurement and control (Cambridge university press, 2009).\n\n\n\nM. Radaelli, G. T. Landi and F. C. Binder. Gillespie algorithm for quantum jump trajectories. Physical Review A 110, 062212 (2024).\n\n\n\n","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = BackAction","category":"page"},{"location":"#BackAction.jl","page":"Home","title":"BackAction.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This is yet another library of Open Quantum Systems.","category":"page"},{"location":"jump_unraveling/#Exported-functions","page":"Jump Unraveling","title":"Exported functions","text":"","category":"section"},{"location":"jump_unraveling/#State-Evaluation","page":"Jump Unraveling","title":"State Evaluation","text":"","category":"section"},{"location":"jump_unraveling/","page":"Jump Unraveling","title":"Jump Unraveling","text":"states_atjumps(traj::Trajectory, sys::System,\n                      psi0::Union{Vector{ComplexF64}, Matrix{ComplexF64}}; normalize::Bool=true)","category":"page"},{"location":"jump_unraveling/#BackAction.states_atjumps-Tuple{Vector{DetectionClick}, System, VecOrMat{ComplexF64}}","page":"Jump Unraveling","title":"BackAction.states_atjumps","text":"states_atjumps(traj::Trajectory, sys::System, psi0::Union{Vector{ComplexF64},\n               Matrix{ComplexF64}}; normalize::Bool=true)\n\nObtain the states at jumps of the trajectory given the initial state psi0, they are (un)normalized if normalize is true(false). The return is an Array of dimensions (sys.NLEVELS, njumps) if the initial state was pure, and (sys.NLEVELS, sys.NLEVELS, njumps) if it was mixed; njumps is the number of jumps in the trajectory. You would access the state at the k-th jump with something like  states_atjumps(traj, sys, psi0)[:, k].\n\nIn case isempty(traj)=true the returned array is also empty.\n\n\n\n\n\n","category":"method"},{"location":"jump_unraveling/","page":"Jump Unraveling","title":"Jump Unraveling","text":"states_att(t_given::Vector{Float64}, traj::Trajectory, sys::System,\npsi0::Union{Vector{ComplexF64}, Matrix{ComplexF64}};normalize::Bool=true)","category":"page"},{"location":"jump_unraveling/#BackAction.states_att-Tuple{Vector{Float64}, Vector{DetectionClick}, System, VecOrMat{ComplexF64}}","page":"Jump Unraveling","title":"BackAction.states_att","text":"states_att(t_given::Vector{Float64}, traj::Trajectory, sys::System,\n                       psi0::Union{Vector{ComplexF64}, Matrix{ComplexF64}};\n                       normalize::Bool=true)\n\nProvided the initial state  psi0 obtain the states at the times in t_given on the trajectory, they are (un)normalized if normalize is true(false).  The return is an Array of dimensions (sys.NLEVELS, ntimes) if the initial state was pure and (sys.NLEVELS, sys.NLEVELS, ntimes) if it was mixed; ntimes is the number of times in t_given. In case isempty(t_given)=true the returned array is also empty.\n\n\n\n\n\n","category":"method"},{"location":"jump_unraveling/#Internal-functions","page":"Jump Unraveling","title":"Internal functions","text":"","category":"section"},{"location":"jump_unraveling/#Utilities","page":"Jump Unraveling","title":"Utilities","text":"","category":"section"},{"location":"jump_unraveling/","page":"Jump Unraveling","title":"Jump Unraveling","text":"BackAction.fixlastindex","category":"page"},{"location":"jump_unraveling/#BackAction.fixlastindex","page":"Jump Unraveling","title":"BackAction.fixlastindex","text":"fixlastindex(array::Array{ComplexF64}, k::Int64)\n\nReturn a SubArray of array, defined by fixing the last index to k.\n\nExample\n\nusing BackAction\narr = [[1+1.0im, 2] [3, 4]]\nBackAction.fixlastindex(arr, 2)\n# output\n2-element view(::Matrix{ComplexF64}, :, 2) with eltype ComplexF64:\n 3.0 + 0.0im\n 4.0 + 0.0im\n\n\n\n\n\n","category":"function"},{"location":"jump_unraveling/#Precomputation","page":"Jump Unraveling","title":"Precomputation","text":"","category":"section"},{"location":"jump_unraveling/","page":"Jump Unraveling","title":"Jump Unraveling","text":"BackAction.setVs!(sys::System, nsamples::Int64, ts::Vector{Float64}, Vs::Array{ComplexF64})","category":"page"},{"location":"jump_unraveling/#BackAction.setVs!-Tuple{System, Int64, Vector{Float64}, Array{ComplexF64}}","page":"Jump Unraveling","title":"BackAction.setVs!","text":"setVs!(sys::System, nsamples::Int64, ts::Vector{Float64}, Vs::Array{ComplexF64})`\n\nCalculate the matrix exponentials mathrmexp(-iH_e t_s) for each t_s in the vector ts, where H_e is the effective hamiltonian of the system sys, and the results are written in Vs, which is an array of dimensions (sys.NLEVELS, sys.NLEVELS, nsamples). To access the exponential corresponding to ts[k] you would do Vs[:, ;, k].\n\n\n\n\n\n","category":"method"},{"location":"jump_unraveling/","page":"Jump Unraveling","title":"Jump Unraveling","text":"BackAction.setQs!(sys::System, nsamples::Int64, ts::Vector{Float64}, Qs::Array{ComplexF64}, Vs::Array{ComplexF64})","category":"page"},{"location":"jump_unraveling/#BackAction.setQs!-Tuple{System, Int64, Vector{Float64}, Array{ComplexF64}, Array{ComplexF64}}","page":"Jump Unraveling","title":"BackAction.setQs!","text":"setQs!(sys::System, nsamples::Int64,ts::Vector{Float64}, Qs::Array{ComplexF64}, Vs::Array{ComplexF64})\n\nCalculate the matrix producs VJV^dagger for each V in  Vs, where  J=sum_k L_k^dagger L_k is  sys.J, and the results are written in Qs which is an array of dimensions  (sys.NLEVELS, sys.NLEVELS, nsamples). To access the product corresponding to ts[k] you would do Qs[:, ;, k].\n\n\n\n\n\n","category":"method"},{"location":"jump_unraveling/","page":"Jump Unraveling","title":"Jump Unraveling","text":"BackAction.precompute!(sys::System, nsamples::Int64, ts::Vector{Float64}, Qs::Array{ComplexF64}, Vs::Array{ComplexF64})","category":"page"},{"location":"jump_unraveling/#BackAction.precompute!-Tuple{System, Int64, Vector{Float64}, Array{ComplexF64}, Array{ComplexF64}}","page":"Jump Unraveling","title":"BackAction.precompute!","text":"precompute!(sys::System, nsamples::Int64, ts::Vector{Float64}, Qs::Array{ComplexF64}, Vs::Array{ComplexF64})\n\nPrecompute the Q(t_s) and V(t_s) necessary for running the Quantum Gillipsie Algorithm  [2] with the time grid ts. The result is written in Qs and Vs. Under the hood, this simply calls setVs! and setQs!.\n\n\n\n\n\n","category":"method"},{"location":"jump_unraveling/#Click-Sampling","page":"Jump Unraveling","title":"Click Sampling","text":"","category":"section"},{"location":"jump_unraveling/","page":"Jump Unraveling","title":"Jump Unraveling","text":"BackAction.calculatewtdweights!(W::Array{Float64}, Qs::Array{ComplexF64}, psi::Vector{ComplexF64}, params::SimulParameters)","category":"page"},{"location":"jump_unraveling/#BackAction.calculatewtdweights!-Tuple{Array{Float64}, Array{ComplexF64}, Vector{ComplexF64}, SimulParameters}","page":"Jump Unraveling","title":"BackAction.calculatewtdweights!","text":"calculatewtdweights!(W::Array{Float64}, Qs::Array{ComplexF64}, psi::Vector{ComplexF64},\n                                        params::SimulParameters)\n\nCalculate the discretized Waiting Time Distribution for a pure state psirangle i.e. langlepsiQ(t_s)psirangle, and writes it at W. This is done using LinearAlgebra's dot, and usually is the thing in which run_singletrajectory spends most of the time since params.nsamples is typically in the thousands.\n\n\n\n\n\n","category":"method"},{"location":"jump_unraveling/","page":"Jump Unraveling","title":"Jump Unraveling","text":"BackAction.calculatewtdweights!(W::Array{Float64}, Qs::Array{ComplexF64}, psi::Matrix{ComplexF64}, params::SimulParameters)","category":"page"},{"location":"jump_unraveling/#BackAction.calculatewtdweights!-Tuple{Array{Float64}, Array{ComplexF64}, Matrix{ComplexF64}, SimulParameters}","page":"Jump Unraveling","title":"BackAction.calculatewtdweights!","text":"calculatewtdweights!(W::Array{Float64}, Qs::Array{ComplexF64}, psi::Matrix{ComplexF64},\n                                         params::SimulParameters)\n\nCalculate the discretized Waiting Time Distribution for a mixed state psi i.e. mathrmTr(Q(t_s)psi), and writes it at W. This is done using LinearAlgebra's tr, and usually is the thing in which run_singletrajectory spends most of the time since params.nsamples is typically in the thousands.\n\n\n\n\n\n","category":"method"},{"location":"jump_unraveling/","page":"Jump Unraveling","title":"Jump Unraveling","text":"BackAction.calculatechannelweights!(P::Vector{Float64}, psi::Vector{ComplexF64}, sys::System)","category":"page"},{"location":"jump_unraveling/#BackAction.calculatechannelweights!-Tuple{Vector{Float64}, Vector{ComplexF64}, System}","page":"Jump Unraveling","title":"BackAction.calculatechannelweights!","text":"calculatechannelweights!(P::Vector{Float64}, psi::Vector{ComplexF64}, sys::System)\n\nCalculate the probabilities for a pure state psirangle to jump to any of the given channels i.e. langlepsi L^dagger Lpsirangle for each jump operator L, and writes it at P.  This is done using the square of LinearAlgebra's norm.\n\n\n\n\n\n","category":"method"},{"location":"jump_unraveling/","page":"Jump Unraveling","title":"Jump Unraveling","text":"BackAction.calculatechannelweights!(P::Vector{Float64}, psi::Matrix{ComplexF64}, sys::System)","category":"page"},{"location":"jump_unraveling/#BackAction.calculatechannelweights!-Tuple{Vector{Float64}, Matrix{ComplexF64}, System}","page":"Jump Unraveling","title":"BackAction.calculatechannelweights!","text":"calculatechannelweights!(P::Vector{Float64}, psi::Matrix{ComplexF64}, sys::System)\n\nCalculate the probabilities for a mixed state psi to jump to any of the given channels i.e. mathrmTr(L^dagger Lpsi) for each jump operator L, and writes it at P.  This is done using of LinearAlgebra's tr.\n\n\n\n\n\n","category":"method"},{"location":"jump_unraveling/#State-Updates","page":"Jump Unraveling","title":"State Updates","text":"","category":"section"},{"location":"jump_unraveling/","page":"Jump Unraveling","title":"Jump Unraveling","text":"BackAction.prejumpupdate!(V::Matrix{ComplexF64}, psi::Vector{ComplexF64}; normalize=false)","category":"page"},{"location":"jump_unraveling/#BackAction.prejumpupdate!-Tuple{Matrix{ComplexF64}, Vector{ComplexF64}}","page":"Jump Unraveling","title":"BackAction.prejumpupdate!","text":"prejumpupdate!(V::Matrix{ComplexF64}, psi::Vector{ComplexF64}; normalize=false)\n\nDo the pure state transformation psirangleto Vpsirangle modifying psi , if normalize=true it also normalizes the final state.\n\n\n\n\n\n","category":"method"},{"location":"jump_unraveling/","page":"Jump Unraveling","title":"Jump Unraveling","text":"BackAction.prejumpupdate!(psi::Vector{ComplexF64}, V::Matrix{ComplexF64},\n                       psi0::Union{Vector{ComplexF64}, SubArray{ComplexF64}}; normalize=false)","category":"page"},{"location":"jump_unraveling/#BackAction.prejumpupdate!-Tuple{Vector{ComplexF64}, Matrix{ComplexF64}, Union{SubArray{ComplexF64}, Vector{ComplexF64}}}","page":"Jump Unraveling","title":"BackAction.prejumpupdate!","text":"prejumpupdate!(psi::Vector{ComplexF64}, V::Matrix{ComplexF64},\n               psi0::Union{Vector{ComplexF64}, SubArray{ComplexF64}}; normalize=false)\n\nDo the pure state transformation psi_0rangleto Vpsi_0rangle and store the result in psi, if normalize=true it also normalizes the final state.\n\n\n\n\n\n","category":"method"},{"location":"jump_unraveling/","page":"Jump Unraveling","title":"Jump Unraveling","text":"BackAction.prejumpupdate!(psi::Matrix{ComplexF64}, V::Matrix{ComplexF64},\n               psi0::Union{Matrix{ComplexF64}, SubArray{ComplexF64}}; normalize=false)","category":"page"},{"location":"jump_unraveling/#BackAction.prejumpupdate!-Tuple{Matrix{ComplexF64}, Matrix{ComplexF64}, Union{SubArray{ComplexF64}, Matrix{ComplexF64}}}","page":"Jump Unraveling","title":"BackAction.prejumpupdate!","text":"prejumpupdate!(psi::Matrix{ComplexF64}, V::Matrix{ComplexF64},\n               psi0::Union{Vector{ComplexF64}, SubArray{ComplexF64}}; normalize=false)\n\nDo the mixed state transformation psi_0to Vpsi_0 V^dagger and store the result in psi, if normalize=true it also normalizes the final state.\n\n\n\n\n\n","category":"method"},{"location":"jump_unraveling/","page":"Jump Unraveling","title":"Jump Unraveling","text":"BackAction.prejumpupdate!(V::Matrix{ComplexF64}, psi::Matrix{ComplexF64}; normalize=false)\n","category":"page"},{"location":"jump_unraveling/#BackAction.prejumpupdate!-Tuple{Matrix{ComplexF64}, Matrix{ComplexF64}}","page":"Jump Unraveling","title":"BackAction.prejumpupdate!","text":"prejumpupdate!(V::Matrix{ComplexF64}, psi::Vector{ComplexF64}; normalize=false)\n\nDo the mixed state transformation psito Vpsi V^dagger modifying psi , if normalize=true it also normalizes the final state.\n\n\n\n\n\n","category":"method"},{"location":"jump_unraveling/","page":"Jump Unraveling","title":"Jump Unraveling","text":"BackAction.postjumpupdate!(L::Matrix{ComplexF64}, psi::Vector{ComplexF64}; normalize=true)","category":"page"},{"location":"jump_unraveling/#BackAction.postjumpupdate!-Tuple{Matrix{ComplexF64}, Vector{ComplexF64}}","page":"Jump Unraveling","title":"BackAction.postjumpupdate!","text":"postjumpupdate!(L::Matrix{ComplexF64}, psi::Vector{ComplexF64}; normalize=true)\n\nDo the pure state transformation psirangleto Lpsirangle modifying psi , if normalize=true it also normalizes the final state.\n\n\n\n\n\n","category":"method"},{"location":"jump_unraveling/","page":"Jump Unraveling","title":"Jump Unraveling","text":"BackAction.postjumpupdate!(L::Matrix{ComplexF64}, psi::Matrix{ComplexF64}; normalize=true)","category":"page"},{"location":"jump_unraveling/#BackAction.postjumpupdate!-Tuple{Matrix{ComplexF64}, Matrix{ComplexF64}}","page":"Jump Unraveling","title":"BackAction.postjumpupdate!","text":"postjumpupdate!(L::Matrix{ComplexF64}, psi::Vector{ComplexF64}; normalize=true)\n\nDo the pure mixed state transformation psito Lpsi L^dagger modifying psi , if normalize=true it also normalizes the final state.\n\n\n\n\n\n","category":"method"},{"location":"jump_unraveling/#Trajectory-Evaluation","page":"Jump Unraveling","title":"Trajectory Evaluation","text":"","category":"section"},{"location":"jump_unraveling/","page":"Jump Unraveling","title":"Jump Unraveling","text":"BackAction.run_singletrajectory(sys::System, params::SimulParameters, W::Vector{Float64}, P::Vector{Float64}, ts::Vector{Float64}, Qs::Array{ComplexF64}, Vs::Array{ComplexF64}; seed::Int64 = 1, isrenewal=false)","category":"page"},{"location":"jump_unraveling/#BackAction.run_singletrajectory-Tuple{System, SimulParameters, Vector{Float64}, Vector{Float64}, Vector{Float64}, Array{ComplexF64}, Array{ComplexF64}}","page":"Jump Unraveling","title":"BackAction.run_singletrajectory","text":"run_singletrajectory(sys::System, params::SimulParameters,\n    W::Vector{Float64}, P::Vector{Float64}, ts::Vector{Float64},\n    Qs::Array{ComplexF64}, Vs::Array{ComplexF64}; seed::Int64 = 1, isrenewal=false)\n\nSample a jump trajectory for the system sys using the  Quantum Gillipsie Algorithm [2].\n\nPositional Arguments\n\nsys::System: the system from which the trajectory is obtained.\nparams::SimulParameters:  specifies the number of points                            in the grid, the initial state and the tolerance for the dark state test.\nW::Vector{Float64}: to store the probabilities of the WTDs used at each step\nP::Vector{Float64}: to store the probabilites of jumps to each channel used at each step\nts::Vector{Float64}: the fine grid used to sample from the WTD\nQs::Array{ComplexF64}: the precomputed matrices from which the WTD weights are calculated\nVs::Array{ComplexF64}:  the precomputed exponentials that evolve the state from jump to jump.\n\nKeyword Arguments\n\nseed::Int64 = 1: the seed of the sample. It does not need to coincide with that in params\nisrenewal = false: whether to optimize the WTD calculation exploiting that the process is renewal,                      if true the WTD is calculated a single time for the whole run.\n\nReturns\n\ntraj::Trajectory: vector with the obtained detection clicks.\n\n\n\n\n\n","category":"method"},{"location":"jump_unraveling/","page":"Jump Unraveling","title":"Jump Unraveling","text":"BackAction.writestate!(states::Array{ComplexF64}, psi::Union{Vector{ComplexF64}, Matrix{ComplexF64}}, counter::Int64)","category":"page"},{"location":"jump_unraveling/#BackAction.writestate!-Tuple{Array{ComplexF64}, VecOrMat{ComplexF64}, Int64}","page":"Jump Unraveling","title":"BackAction.writestate!","text":"writestate!(states::array{complexf64}, psi::union{vector{complexf64},\n                                        matrix{complexf64}}, counter::int64)\n\nWrites psi in states at the subarray with the last index fixed at counter.\n\n\n\n\n\n","category":"method"}]
}
