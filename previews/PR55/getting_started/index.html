<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Getting Started · BackAction.jl</title><meta name="title" content="Getting Started · BackAction.jl"/><meta property="og:title" content="Getting Started · BackAction.jl"/><meta property="twitter:title" content="Getting Started · BackAction.jl"/><meta name="description" content="Documentation for BackAction.jl."/><meta property="og:description" content="Documentation for BackAction.jl."/><meta property="twitter:description" content="Documentation for BackAction.jl."/><meta property="og:url" content="https://github.com/Ste1nb0cK/BackAction.jl/getting_started/"/><meta property="twitter:url" content="https://github.com/Ste1nb0cK/BackAction.jl/getting_started/"/><link rel="canonical" href="https://github.com/Ste1nb0cK/BackAction.jl/getting_started/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/style.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">BackAction.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>Getting Started</a><ul class="internal"><li><a class="tocitem" href="#Installation"><span>Installation</span></a></li><li><a class="tocitem" href="#Example:-Jump-Unraveling-of-a-Driven-Qubit"><span>Example: Jump Unraveling of a Driven Qubit</span></a></li><li><a class="tocitem" href="#Basic-Definitions"><span>Basic Definitions</span></a></li><li><a class="tocitem" href="#Sampling-trajectories"><span>Sampling trajectories</span></a></li><li><a class="tocitem" href="#Obtaining-the-states-and-evaluating-observables"><span>Obtaining the states and evaluating observables</span></a></li><li><a class="tocitem" href="#Multithreading"><span>Multithreading</span></a></li><li><a class="tocitem" href="#More-Examples"><span>More Examples</span></a></li></ul></li><li><a class="tocitem" href="../system_simulparams/">System and SimulParameters</a></li><li><a class="tocitem" href="../jump_unraveling/">Jump Unraveling</a></li><li><a class="tocitem" href="../monitoring_metrology/">Monitoring Quantum Metrology</a></li><li><a class="tocitem" href="../utilities/">Utilities</a></li><li><a class="tocitem" href="../bibliography/">Bibliography</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Getting Started</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Getting Started</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/Ste1nb0cK/BackAction.jl/blob/main/docs/src/getting_started.md#" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h2 id="Installation"><a class="docs-heading-anchor" href="#Installation">Installation</a><a id="Installation-1"></a><a class="docs-heading-anchor-permalink" href="#Installation" title="Permalink"></a></h2><p>For the moment the library is not available through Pkg, so you will need to clone the repository </p><pre><code class="language-console hljs">$ git clone https://github.com/Ste1nb0cK/BackAction.jl</code></pre><p>and build it with <code>] develop path_to_clonedrepo</code> in the Julia REPL, this automatically adds it to your current project. </p><pre><code class="language-julia hljs">import Pkg; Pkg.develop(path=&quot;./BackAction.jl&quot;)</code></pre><p>To check the installation do</p><pre><code class="language-julia hljs">Pkg.status</code></pre><p>and you should see <code>BackAction</code> in the output e.g.</p><pre><code class="language-console hljs">  [32f8aca8] BackAction v0.1.0 `..`
  [e30172f5] Documenter v1.8.0
  [daee34ce] DocumenterCitations v1.3.5
  [b964fa9f] LaTeXStrings v1.4.0
  [91a5bcdd] Plots v1.40.9
  [10745b16] Statistics v1.10.0
  [8dfed614] Test
</code></pre><h2 id="Example:-Jump-Unraveling-of-a-Driven-Qubit"><a class="docs-heading-anchor" href="#Example:-Jump-Unraveling-of-a-Driven-Qubit">Example: Jump Unraveling of a Driven Qubit</a><a id="Example:-Jump-Unraveling-of-a-Driven-Qubit-1"></a><a class="docs-heading-anchor-permalink" href="#Example:-Jump-Unraveling-of-a-Driven-Qubit" title="Permalink"></a></h2><p>To explain how the library works  we&#39;ll consider a driven qubit in a thermal enviroment,  whose density matrix follows the Lindblad equation [<a href="../bibliography/#wiseman2009quantum">1</a>]:</p><p class="math-container">\[\dot{\rho}=-i[H,\rho]+\gamma(n+1)\mathcal{D}[\sigma^-]\rho+\gamma n\mathcal{D}[\sigma^+]\rho\]</p><p>where <span>$\sigma^- (\sigma^+)$</span> is the lowering (raising) atomic operator and</p><p class="math-container">\[H=\frac{1}{2}\Delta\sigma_z+\frac{1}{2}\Omega\sigma_x\]</p><p class="math-container">\[\mathcal{D}[\sigma^\pm]\rho = \sigma^\pm\rho\sigma^\mp-\frac{1}{2}\{\sigma^\mp\sigma^\pm, \rho\}.\]</p><p>To it we associate the <em>Stochastic Jump Unraveling</em>:</p><p class="math-container">\[d\rho=-i[H,\rho]dt+\left(\frac{\sigma^-\rho\sigma^+}{\mathrm{Tr}{(\sigma^-\rho\sigma^+)}}-\rho\right)dN_1
+ \left(\frac{\sigma^+\rho\sigma^-}{\mathrm{Tr}{(\sigma^+\rho\sigma^-)}}-\rho\right)dN_2\]</p><p>whose ensemble average returns the Lindblad equation. Our objective, and the main functionality  of the library, is to sample trajectories of this type of equations and obtain from them relevant physical quantities.</p><h2 id="Basic-Definitions"><a class="docs-heading-anchor" href="#Basic-Definitions">Basic Definitions</a><a id="Basic-Definitions-1"></a><a class="docs-heading-anchor-permalink" href="#Basic-Definitions" title="Permalink"></a></h2><p>The basic way to use the library is to first define the system and  the conditions of the simulation via the structs <code>System</code> and <code>SimulParameters</code> (see <a href="../system_simulparams/#basic_structs">System and SimulParameters</a>). </p><h3 id="Defining-the-System"><a class="docs-heading-anchor" href="#Defining-the-System">Defining the System</a><a id="Defining-the-System-1"></a><a class="docs-heading-anchor-permalink" href="#Defining-the-System" title="Permalink"></a></h3><p><code>System</code> is the struct intended to store all the relevant information of the system of interest. </p><pre><code class="language-julia hljs">using BackAction
delta = 1.43
gamma = 1.0
omega = 1.3
nbar = 0.2
# Note: the library already has a dedicated variables for the Pauli matrices.
H = 0.5*delta * BackAction.sigma_z + 0.5*omega*BackAction.sigma_x
# Define the jump operators
L1 = sqrt(gamma*(nbar+1))*BackAction.sigma_m
L2 = sqrt(gamma*(nbar))*BackAction.sigma_p
sys = System(H, [L1, L2])
print(sys)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">System(NLEVELS=2
NCHANNELS=2
H=ComplexF64[-0.715 + 0.0im 0.65 + 0.0im; 0.65 + 0.0im 0.715 + 0.0im]
Ls=Matrix{ComplexF64}[[0.0 + 0.0im 1.0954451150103321 + 0.0im; 0.0 + 0.0im 0.0 + 0.0im], [0.0 + 0.0im 0.0 + 0.0im; 0.4472135954999579 + 0.0im 0.0 + 0.0im]]
J=ComplexF64[0.19999999999999998 + 0.0im 0.0 + 0.0im; 0.0 + 0.0im 1.1999999999999997 + 0.0im])
Heff=ComplexF64[-0.715 - 0.09999999999999999im 0.65 + 0.0im; 0.65 + 0.0im 0.715 - 0.5999999999999999im])</code></pre><p>As you can see to create a <code>System</code> type one only needs the hamiltonian and the jump operators, the internal constructor takes care of infering all the derived quantities.</p><h3 id="Defining-the-Simulation"><a class="docs-heading-anchor" href="#Defining-the-Simulation">Defining the Simulation</a><a id="Defining-the-Simulation-1"></a><a class="docs-heading-anchor-permalink" href="#Defining-the-Simulation" title="Permalink"></a></h3><p>All the information related to the details of generating a sample is organized with the struct <code>SimulParameters</code>. The initial state might be mixed (<code>Matrix</code>) or pure (<code>Vector</code>), the library takes care of handling each case  efficiently.</p><pre><code class="language-julia hljs"> # As initial condition use a mixture of |+&gt; and |-&gt; states
plus = 0.5* [[1.0+0im, 1] [1,  1]]
minus = 0.5* [[1.0+0im, -1] [-1,  1]]
psi0 = 0.3*plus + 0.7*minus

params = SimulParameters(psi0,
    25.0, # Final time
    1, # seed
    3, # Number of trajectories
    25_000, # Number of samples in the finegrid
    4.0, # Multiplier to use in the fine grid
    1e-3 # Tolerance for passing Dark state test
)
print(params)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">SimulParameters(psi0=ComplexF64[0.5 + 0.0im -0.19999999999999998 + 0.0im; -0.19999999999999998 + 0.0im 0.5 + 0.0im]
nsamples=25000
seed=1
ntraj=3)
multiplier=4.0
tf=25.0
dt=0.004
eps=0.001)</code></pre><p>For the moment the only available method of solution is the /Quantum Gillipsie Algorithm/ presented in [<a href="../bibliography/#radaelli2024gillespie">2</a>]. The multiplier is used to generate the finegrid from which one samples the waiting times. Basically that finegrid is a discretization of <code>(dt, params.multiplier * params.tf)</code> with step size <code>params.dt</code>. A small but important difference with the <a href="https://github.com/marcoradaelli/GillespieQuantumJumps">original implementation</a>is that here in each iteration the normalization of the WTD is checked; in case of undernormalization the current state is declared dark and the sampling stops. Sample quality strongly depends on the size of <code>dt</code>, but in contrast to other methods it&#39;s not necessary for it to be effectevely infinitesimal, small enough to resolve the structure of the WTD will suffice.</p><p>The main bottleneck is in the calculation of the WTD at each jump, this means that the factors that affect the time it takes to sample a single trajectory are mainly the number of samples and total number of jumps that happen in it.</p><h3 id="ClickDetection-and-Trajectory"><a class="docs-heading-anchor" href="#ClickDetection-and-Trajectory">ClickDetection and Trajectory</a><a id="ClickDetection-and-Trajectory-1"></a><a class="docs-heading-anchor-permalink" href="#ClickDetection-and-Trajectory" title="Permalink"></a></h3><p>The data about a click is modeled by the struct <code>DetectionClick</code> <a href="../system_simulparams/#BackAction.DetectionClick">(more info)</a>, this in practice works as a glorified tuple. Similarly, the library has an alias for <code>Vector{DetectionClick}</code> called <code>Trajectory</code>. </p><h2 id="Sampling-trajectories"><a class="docs-heading-anchor" href="#Sampling-trajectories">Sampling trajectories</a><a id="Sampling-trajectories-1"></a><a class="docs-heading-anchor-permalink" href="#Sampling-trajectories" title="Permalink"></a></h2><p>To obtain a sample of trajectories one uses <code>run_trajectories</code>, this returns a vector of trajectories as the sample :</p><pre><code class="language-julia hljs">data = run_trajectories(sys, params)
for k in 1:3
    println(data[k])
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Sampling...  67%|█████████████████▍        |  ETA: 0:00:01 ( 0.73  s/it)Sampling... 100%|██████████████████████████| Time: 0:00:02 ( 0.67  s/it)
DetectionClick[DetectionClick(0.004, 1), DetectionClick(3.864, 2), DetectionClick(0.23199999999999998, 1), DetectionClick(2.904, 2), DetectionClick(1.6400000000000001, 1), DetectionClick(22.144, 2)]
DetectionClick[DetectionClick(0.7040000000000001, 2), DetectionClick(26.94, 1)]
DetectionClick[DetectionClick(4.648, 2), DetectionClick(1.128, 1), DetectionClick(1.536, 1), DetectionClick(0.88, 2), DetectionClick(0.7040000000000001, 1), DetectionClick(1.3519999999999999, 2), DetectionClick(0.112, 1), DetectionClick(0.128, 2), DetectionClick(1.784, 2), DetectionClick(0.208, 1), DetectionClick(0.5519999999999999, 2), DetectionClick(1.524, 2), DetectionClick(0.02, 1), DetectionClick(10.443999999999999, 1)]</code></pre><p>The first element shown of a <code>DetectionClick</code> is the time it took since the last jump to see this click,  and the channel in which it was detected.</p><p>We can access the clicks in a trajectory doing:</p><pre><code class="language-julia hljs"> traj = data[1] # Trajectory
 click = traj[1] # first click in the trajectory
 print(click.time,&quot;\n&quot;) # time we waited to see the jump
 print(click.label, &quot;\n&quot;) # Channel in which the jump occured.</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">0.004
1</code></pre><h2 id="Obtaining-the-states-and-evaluating-observables"><a class="docs-heading-anchor" href="#Obtaining-the-states-and-evaluating-observables">Obtaining the states and evaluating observables</a><a id="Obtaining-the-states-and-evaluating-observables-1"></a><a class="docs-heading-anchor-permalink" href="#Obtaining-the-states-and-evaluating-observables" title="Permalink"></a></h2><p>To obtain the states of a trajectory at given times the function <code>states_att</code> is used, it evaluates them  from a given initial state and returns an array. Below we use to obtain a sample of the expectation values of the Pauli matrices</p><pre><code class="language-julia hljs">using LinearAlgebra, Plots, LaTeXStrings
ntimes = 1000
tgiven = collect(LinRange(0, params.tf, ntimes));
statetrajectory = states_att(tgiven, traj, sys,  params.psi0)

# Obtain sigma_z expectation value over the trajectory
r_trajectory = zeros(ComplexF64, ntimes, 3)
for tn in 1:ntimes
   r_trajectory[tn, 1] = tr(BackAction.sigma_x*statetrajectory[:,:, tn])
   r_trajectory[tn, 2] = tr(BackAction.sigma_y*statetrajectory[:,:, tn])
   r_trajectory[tn, 3] = tr(BackAction.sigma_z*statetrajectory[:,:, tn])
end

plot(tgiven, real.(r_trajectory[:, 1]), xlabel=L&quot;t&quot;, ylabel=L&quot;\langle\sigma\rangle&quot;, color=&quot;red&quot;,
    line=:dash, label=L&quot;\langle\sigma_x\rangle&quot;)
plot!(tgiven, real.(r_trajectory[:, 2]), color=&quot;blue&quot;,
    line=:dash, label=L&quot;\langle\sigma_y\rangle&quot;)
plot!(tgiven, real.(r_trajectory[:, 3]), color=&quot;green&quot;,
    line=:dash, label=L&quot;\langle\sigma_z\rangle&quot;)</code></pre><img src="847ad4a8.svg" alt="Example block output"/><h2 id="Multithreading"><a class="docs-heading-anchor" href="#Multithreading">Multithreading</a><a id="Multithreading-1"></a><a class="docs-heading-anchor-permalink" href="#Multithreading" title="Permalink"></a></h2><p>The library natively supports multithreading, all you need to do is run with the desired number of threads specified in the enviroment variable <code>JULI_NUM_THREADS</code> i.e. do something like <code>export JULIA_NUM_THREADS=4</code>.</p><p>That would be it!</p><h2 id="More-Examples"><a class="docs-heading-anchor" href="#More-Examples">More Examples</a><a id="More-Examples-1"></a><a class="docs-heading-anchor-permalink" href="#More-Examples" title="Permalink"></a></h2><p>You can find more elaboted examples in the Jupyter Notebooks available at the <a href="https://github.com/Ste1nb0cK/BackAction.jl/tree/5ed9dd8e60f16a799882b3e3a22aec53fe7428b2/notebooks">repository</a>.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><a class="docs-footer-nextpage" href="../system_simulparams/">System and SimulParameters »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.8.0 on <span class="colophon-date" title="Monday 3 February 2025 14:37">Monday 3 February 2025</span>. Using Julia version 1.11.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
